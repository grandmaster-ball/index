---
layout: post
title: Path Sum 三题112 113 437
date: 2022-10-07
Author: keen
tags: [递归,二叉树,DFS,]
comments: false
toc: true
---
# 112-Path Sum I
## 题目：Easy
- 对于一颗二叉树，给定一个值sum，问是否存在某条路径使得路径和等于目标值

![path_I](https://lh3.googleusercontent.com/u/0/d/1f0bgfzciau3aPCvxq5w35G3J2aWduCbc)

```cpp
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root ) return false;                                                    //退出条件
        targetSum -= root->val;                                                     
        if(targetSum == 0&&!root->left&&!root->right) return true;                  //递归
        return hasPathSum(root->left,targetSum)||hasPathSum(root->right,targetSum);
    }
```

- 一层一层减去，减去完递归，直到找到为止
- 判断条件很巧妙的使用了 如果有一个找到了，就自上而下的全都变成true
```cpp
    return hasPathSum(root->left,targetSum)||hasPathSum(root->right,targetSum);
```

# 113-Path Sum II
## 题目：Normal
- 对于一颗二叉树，给定一个值sum，问存在什么样子的路径使得路径和等于目标值，返回路径

![path II](https://lh3.googleusercontent.com/u/0/d/1sVC1ccP5u6dFe1rXRlLZpu-uu7O67677)

```cpp
    vector<vector<int>> ans;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<int> path;
        dfs(root,targetSum,path);
        return ans;
    }
    void dfs(TreeNode* root,int targetSum,vector<int> & path){
        if(!root) return;
        path.push_back(root->val);                              //先推到path里去
        targetSum -= root->val;
        if(targetSum == 0&&!root->left&&!root->right){
            ans.push_back(path);                                //满足条件就给他拿走
        }
        dfs(root->left,targetSum,path);                         //递归
        dfs(root->right,targetSum,path);    
        path.pop_back();                                        //这个走完了，去掉
    }
```

- 首先来一个path用来装路
- 走到哪记录path到哪里，如果满足了，就把path push到最上面的ans去
- 递归一下把所有的都跑了
- 这个地方没作用了就给他从路径里pop了

# 437-Path Sum III
## 题目：Normal
- 在一棵树上，给定目标值，问：连续的某一段路径和等于目标值的数目
- ![path II](https://lh3.googleusercontent.com/u/0/d/1vxbmgotYQcQeMX7Qv-2b2C42v5Cb0SkZ)





